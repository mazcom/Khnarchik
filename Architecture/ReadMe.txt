Что на самом деле предоставляет framework.
WEB - это механизм коммункации.

Архитектура - это "Почему, а не как".
Библиотеки и фреймвокри - детали реализации, которые должны быть скрыты.


WEB - это устройство ввода- вывода. Это плагин к бизнес-домену.


Итак,

UI/API - это плагин
-------------------
BUSINESS Domain
-------------------
DB Entities - это плагин

Суть clean architecture - кто от кого зависит.
Внутри entities- это наши бизнес правила. Не зависят ни от кого.


Преимущества:
-независимость от фреймфорков
-независимость от БД
-независимость от транспорта
-простота тестирования
-принимаем решение как можно позже
-хорошая модульность
-архитектура может защищать сама себя.


Как готовить?
-положить бизнес правила в центр
-следить чтобы бизнес правила были независимыми
-все IO операции - плагины
-чтобы из бизнеса перепрыгнуть на инфраструктуру используйте интерфейсы
-следить чтобы плагины не знали о друг друге, а знали о бизнесе.


Что не так с чистой архитектурой.
-где границы бизнес-модулей?
-есть вероятность скатывания в анемичную модель


Соединяем всё вместе:
-Чистая архитеткруа обеспечивает отвязку от деталей реализации.
-Лёгкая замена деталей реализации
-легче писать
-бонус: очень предсказуемый код


Чем прийдется запоатить:
- В некторых местах будет больше кода
- Будет большое количество классов
- Понадобится отдельное DTO на границах




// следующий доклад
https://www.youtube.com/watch?v=Bd83nPK_K3U&ab_channel=DotNext

что такое архитектура?
Святая троица:
-компоненты системы
-их публичные контракты
-связи между компонентами


Инверсия зависимостей:

Модули верхнего уровня и модули нижнего уровня должны зависсеть от абстракций
Н-р:
Есть Business Logic ->(зависит от) DataAccess

Это неправильно.
Добавим модуль интерфейс DataAcessInterface
Logic -> DataAcessInterface <- DataAccess

Что такое компонент:
Это минимальная единица, которая может быть задеплоена(exe или dll).


Entities - это бизнес логика. Логика создания заказа. Выставления счёта. 
Тут же находятся правила и их обработка.
-Rich model
-Anemic Model + Domain Services
-Здесь нет интерфейсов репозиториев.


Use cases - это логика приложения. это сценарии использования 
-Это как пользователь взаимодействует с нашим приложением. 
-Не зависит от фреймворков(ORM,WEB)
-Не знают откуда вызываются
-Сервисы CQRS

Interfaces Adapters
-связывают use cases с внешним миром.
-контроллеры
-доступ к данным
-внешние сервисы
-Timer / service bus worker


frameworks:
-база данных
-web
-swagger
-тесты


Дядушка Боб говорит что это только отправная точка. 
Можно добавлять новые компоненты, но нужно соблюдать правила зависимостей.
Это Shared компоненты:
Набор экстеншонов, утилит. Расширения для нашего фреймворка.
- IDateTime
  UtcNow
Extensions/ Utils
 -Date
 - String

Pagination
Validation


Entities:
-Сущности
-Перечисления
-Исключения
-Доменные события
-Базовые классы - супертип слоя

Контракт:
 Все классы публичные
 Связи не зависит от других проектов(shared не в счёт)
 
 
Web- корень композиции
- Проект который знает про всех
- Инфраструктура хоста
- Централизованная обработка иссключений.

Т.е. он собирает и регистрирует все модули.

CQRS stands for Command and Query Responsibility Segregation

Н-р: был сервис  OrdersService.
getById
Create

Разделится на:
GetByIdQuery
-getByidQuery
-OrderDto

CreateOrderCommand
-CreateOrderDto
-Handler

CQRS - резюме
Вместо одного универсального сервиса - много специализированных handlers
Контракт














 


 





 

 







 







 







