JavaScript — это современный язык программирования и партнер HTML и CSS. 
Если коротко, этот язык позволяет привнести в документ интерактивность. Вот краткий перечень возможностей, которые предоставляет JavaScript:

-Прослушивание событий, будь то клик мыши или выполнение команды.
-Изменение HTML- и CSS-страниц после их загрузки.
-Задание незаурядных траекторий перемещения объектов по экрану.
-Создание увлекательнейших браузерных игр вроде Cut the Rope.
-Обмен данными между сервером и браузером.
-Взаимодействие с веб-камерой, микрофоном и другими устройствами.


//online JavaScript variable name validator
https://mothereff.in/js-variables



Объявление переменной не обязательно
Например, нам не обязательно использовать ключевое слово let, чтобы объявить переменную. Можно просто написать так:
myText = "hello, world!";
alert(myText);

И хотя так делать и не рекомендуется, это считается вполне допустимым. 
В конечном счете мы получаем переменную с именем myText. 
Единственный нюанс состоит в том, что при объявлении переменной подобным образом мы делаем это глобально.


Изменение значений переменных и ключевое слово const
И наконец, отмечу, что мы можем менять значение переменной, объявленной с let, на что угодно и когда угодно:
let myText;
myText = "hello, world!";
myText = 99;
myText = 4 * 10;
myText = true;
myText = undefined;
alert(myText);

Тем не менее в JavaScript есть способ запретить изменять значения переменной после инициализации. Это можно сделать с помощью ключевого слова const, с которым мы можем объявлять и инициализировать переменные:
const siteURL = "https://www.google.com";
alert(siteURL);


АЛЬТЕРНАТИВА ALERT
В предыдущих главах мы использовали функцию alert для отображения текста на экране. 
В этой главе мы познакомимся с другим, не столь навязчивым способом отображения. И это будет функция document.write:
// выводит прямо в документ.
document.write("Show this on screen!");

Допустим, нужно, чтобы функция showAlert была вызвана через 5 секунд. В этом случае объявление функции setTimeout будет выглядеть так:

function showAlert() {
alert("moo!");
}
let timeoutID = setTimeout(showAlert, 5000);

Можно легко отменить функцию setTimeout с помощью функции clearTimeout, в которую в качестве аргумента нужно передать ID таймаута (timeoutID):
clearTimeout(timeoutID);



Следующая функция-таймер, которую мы рассмотрим, — это setInterval. Она похожа на setTimeout в том, что позволяет выполнять код спустя определенное время. Отличие же ее в том, что она не просто выполняет код один раз, а продолжает его повторное выполнение бесконечно.
Вот как она используется:
let intervalID = setInterval(someFunction, delayInMilliseconds);


Для прекращения выполнения цикла мы можем использовать функцию clearInterval с соответствующим аргументом:
clearInterval(intervalID);


Настало время перейти к моей любимой функции: requestAnimatonFrame. Эта функция создана для синхронизации кода с событием перерисовки содержимого браузера. 
Поясняю подробнее: в любой момент браузер занят обработкой миллиона различных элементов. 
Среди них: 
- манипуляции с макетом, 
- реакция на прокрутку страниц, 
- прослушивание кликов мыши, 
- отображение результатов нажатий клавиатуры, 
- исполнение кода, 
- загрузки ресурсов и т. д. 
Одновременно со всем этим он также перерисовывает экран со скоростью 60 кадров в секунду, ну или пытается это делать.

Браузеры воспринимают эту функцию особым образом, что позволяет задавать время ее выполнения наиболее оптимально, избегая провала частоты кадров, а также ненужных действий и прочих побочных эффектов, мешающих применению других решений, связанных с выполнением циклов.
Запуск этой функции почти такой же, как в случае с setTimeout / setInterval:
let requestID = requestAnimationFrame(someFunction);
Единственное заметное отличие состоит в том, что мы не задаем значение продолжительности. 
Это значение вычисляется автоматически в зависимости от: текущей скорости обновления кадров, активна ли текущая вкладка или нет, 
работает ли устройство от батареи или сети и многих других факторов, выходящих


Ключом ко всем анимациям, создаваемым в JavaScript, является анимационный цикл, и именно к этому циклу нам нужно применить requestAnimationFrame. Результат такого применения выглядит следующим образом:

function animationLoop() {
// код, отвечающий за анимацию
requestAnimationFrame(animationLoop)
}
// Начать выполнение цикла анимации!
animationLoop();


ОБЛАСТЬ ВИДИМОСТИ ПЕРЕМЕННЫХ

ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННЫХ БЕЗ ОБЪЯВЛЕНИЯ
Если мы инициализируем переменную state, не объявляя ее формально, область ее видимости будет определяться совсем иначе:
function setState() {
state = "on";
}
setState(); alert(state) // "on"

Хотя в этом случае переменная state и появляется внутри функции setState, сам факт того, 
что мы объявили ее без let, const (или var — устаревший способ объявления переменных), делает ее глобальной. 
По большому счету, вам не понадобится объявлять переменные подобным образом. Поэтому всегда используйте let или const.

var — устаревший способ объявления переменных


Область видимости переменных, объявленных с var, ограничивается уровнем функций, поэтому если переменная объявляется в любом месте внутри функции, 
то считается, что она находится в области видимости. Область же видимости переменных, объявленных с let, как мы увидели ранее, определяется уровнем блока.
Степень свободы, с которой переменная var определяет область видимости, слишком большая, и поэтому легко допустить ошибку, связанную с переменными. 
По этой причине я ратую за использование let, когда дело доходит до объявления переменных.


Когда JavaScript при выполнении достигает определенной области (глобальной, функции и т. д.), то первое, что он делает, — полностью сканирует тело кода в поиске объявленных переменных. 
Если он встречает переменные, объявленные с var, то по умолчанию инициализирует их как undefined. 
Если же они объявлены с let или const, он оставляет их полностью неинициализированными.
При завершении он перемещает все встреченные переменные в верхнюю часть соответствующей им области, которой в случае с let и const является ближайший блок, 
а в случае с var — ближайшая функция.

Давайте подробнее рассмотрим, что это значит. Изначально наш код выглядит так:
alert(foo);
let foo = "Hello!";

Когда JavaScript приступает к его обработке, код принимает следующий вид:
let foo;
alert(foo);
foo = "Hello!";

Несмотря на то что переменная foo была объявлена в нижней части кода, она смещается вверх. 
Формально это называется поднятием переменной. Особенность let и const в том, что при поднятии переменные остаются неинициализированными. 
Если вы попробуете обратиться к неинициализированной переменной, то код выдаст ошибку и прекратит выполнение.


Если мы изменим предыдущий пример, используя var, то в итоге для JavaScript код будет выглядеть так:
var foo = undefined;
alert(foo);
foo = "Hello!";
Переменная по-прежнему поднимается, но при этом инициализируется как undefined, благодаря чему код продолжает выполнение.



ЗАМЫКАНИЯ


 function stopWatch() {
            let startTime = Date.now();
            function getDelay() {
                let elapsedTime = Date.now() - startTime;
                alert(elapsedTime);
            }
            return getDelay;
        }

        let timer = stopWatch();
        // Сделать что-нибудь за некоторое время.
        for (let i = 0; i < 1000000; i++) {
            let foo = Math.random() * 10000;
        }
        // Вызвать возвращаемую функцию.
        timer();
		
		
Рабочая среда JavaScript, отслеживающая все переменные, использование памяти, ссылок и т. д., действительно умна. 
В нашем примере ею обнаружено, что внутренняя функция (getDelay) опирается на переменные из внешней функции (stopWatch). 
Когда это происходит, рабочая среда обеспечивает, чтобы любые нужные переменные из внешней функции были доступны внутренней функции, даже если внешняя функция перестает действовать.

Формально замыкание можно определить как вновь созданную функцию, которая также содержит свой переменный контекст (рис. 9.11).


ГДЕ МОЖНО РАЗМЕЩАТЬ КОД?


Подход № 1: весь код в HTML-документе

Когда ваш браузер загружает страницу, он поочередно считывает каждую строку кода в HTML-документе сверху вниз. Дойдя до тега
script, он также обрабатывает все строки JavaScript-кода. 
Закончив выполнение, он продолжает считывать оставшуюся часть документа. Это значит, что местоположение тега script очень важно.

Подход № 2: код существует в отдельном файле
В этом случае наш основной HTML-документ не содержит никакого JS-кода. Вместо этого весь код располагается в отдельном документе. 
Такой подход разделен на две части. Первая относится к самому файлу JavaScript, а вторая отвечает за связь этого файла с HTML.


<!DOCTYPE html>
<html>
<body>
<h1>Example</h1>
<script src="example.js"></script>
</body>
</html>


СЧИТЫВАНИЕ И РАСПОЛОЖЕНИЕ СЦЕНАРИЕВ В ДОКУМЕНТЕ

Несколькими разделами ранее я описывал выполнения сценариев. 
Браузер считывает HTML-страницу, начиная сверху и построчно перемещаясь вниз. 
Когда он достигает тега script, то начинает выполнять содержащийся в нем код. Это выполнение также происходит построчно, начинаясь с верхней части. 
ВСЕ ОСТАЛЬНЫЕ ВОЗМОЖНЫЕ ДЕЙСТВИЯ СТРАНИЦЫ НА ВРЕМЯ ЭТОГО ВЫПОЛНЕНИЯ ПРИОСТАНАВЛИВАЮТСЯ. 
ЕСЛИ ТЕГ SCRIPT ССЫЛАЕТСЯ НА ВНЕШНИЙ JS-ФАЙЛ, ТО ПРЕЖДЕ, ЧЕМ НАЧАТЬ ВЫПОЛНЕНИЕ ЭТОГО ФАЙЛА, БРАУЗЕР ЕГО ЗАГРУЗИТ.

При таком линейном считывании документа браузером наблюдается интересные нюансы, влияющие на то, где лучше размещать теги script. 
Технически их можно разместить в любой части HTML-документа. Тем не менее для этого есть предпочтительное место. 
Учитывая то, как браузер считывает страницу, и то, что он все блокирует во время выполнения сценариев, следует размещать теги script в нижней части HTML-документа, после всех его элементов.

Если тег script окажется в верхней части документа, то на время его выполнения браузер заблокирует все остальное. 
В результате если вы начнете загружать большой файл сценария или будете выполнять сценарий, то пользователь сможет увидеть частично загруженную и не отвечающую HTML страницу. 
До тех пор пока у вас не возникнет реальной потребности в выполнении JavaScript до полного считывания документа, размещайте теги script в конце, как показано в большинстве предыдущих примеров. 
Есть и еще одно преимущество в расположении скриптов внизу страницы, но о нем я расскажу значительно позднее, когда мы будем говорить о DOM (объектная модель документа) и о том, 
что происходит в процессе загрузки страницы.
Конечный выбор подхода зависит от ответа на следующий вопрос: «Планируется ли использование одного и того же кода в нескольких HTML-документах?»


CONSOLE

вывод оранжевым и красным.
console.warn("This is a warning!");
console.error("This is an error!");


ТИПЫ ДАННЫХ:
Примитивные: string, number, boolean, null, bigint, symbol и undefined. Любые значения, попадающие в их юрисдикцию, не подлежат делению на части.


ПРЕДОПРЕДЕЛЕННЫЕ ОБЪЕКТЫ В JAVASCRIPT:
Array Помогает хранить, извлекать и манипулировать наборами данных
Boolean Служит оболочкой примитива Boolean, а также работает посредством значений true и false 
Date Упрощает работу с датами и их представление
Function Позволяет вызывать заданный код
Math Умник среди типов, расширяющий возможности работы с числами
Number Служит оболочкой примитива number
RegExp Предоставляет богатые возможности сопоставления текстовых шаблонов
String Служит оболочкой примитива string


МАССИВЫ

// пустой массив:
let groceries = [];


// перебрать массив
for (let i = 0; i < groceries.length; i++) {
let item = groceries[i];
}

// добавить элемент вконец
groceries.push("Cookies");

Если же вы хотите добавить данные в начало, используйте метод unshift:
groceries.unshift("Bananas");


// удаление элемента
let lastItem = groceries.pop();

// удаление первого элемента.
let firstItem = groceries.shift();


Поиск элементов в массиве
Для поиска элементов внутри массива существует несколько методов: indexOf, lastIndexOf, includes, find, findIndex и filter.


Слияние массивов
let good = ["Mario", "Luigi", "Kirby", "Yoshi"];
let bad = ["Bowser", "Koopa Troopa", "Goomba"];

let goodAndBad = good.concat(bad);


ОТОБРАЖЕНИЕ, ФИЛЬТРАЦИЯ И СОКРАЩЕНИЕ МАССИВОВ:

Помимо этого, массивы предлагают простые способы управления содержащимися в них данными. Эти простые способы представлены методами: 
map (отображение), 
reduce (сокращение) 
filter (фильтрация).

map:
Начнем с метода map, который мы используем для модификации всех элементов массива во что-либо другое, представленное в виде нового массива

let newArray = originalArray.map(someFunction);

Работает метод map так: вы вызываете его для массива, на который хотите воздействовать (originalArray), и передаете ему функцию (someFunction) в качестве аргумента. 
Функция будет выполняться для каждого элемента массива, то есть вы изначально сможете написать код для изменения всех этих элементов на ваше усмотрение. 
В конечном итоге вы получите новый массив, содержащий данные, полученные после выполнения функции someFunction для элементов оригинального массива.

let names = ["marge", "homer", "bart", "lisa", "maggie"];
function capitalizeItUp(item) {
let firstLetter = item.charAt(0).toUpperCase();
return firstLetter + item.slice(1);
}
let newNames = names.map(capitalizeItUp);
console.log(newNames);


filter фильтрация элементов:

let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];

let evenNumbers = numbers.filter(function (item) {
return (item % 2 == 0);
});


reduce:
Используя метод reduce, мы по-прежнему будем начинать с массива. А вот в конце будем получать всего одно значение

let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];

let total = numbers.reduce(function(total, current) {
return total + current;
}, 0);
console.log(total)

В данном случае ей приходится иметь дело с двумя аргументами:
- первый содержит итоговое значение, полученное в результате всех произведенных на этот момент действий;
- второй — это текущий элемент массива.


СТРОКИ

Работать со строками в коде легко. При этом нам просто нужно заключать их в одинарные или двойные кавычки. 
Вот некоторые примеры:

let text = "this is some text";
let moreText = 'I am in single quotes!';

Метод slice

Метод slice позволяет нам определять начальную и конечную позиции интересующей части строки, которую мы хотим извлечь:

let theBigString = "Pulp Fiction is an awesome movie!";
console.log(theBigString.slice(5, 12));
В этом примере мы извлекаем знаки между индексами 5 и 12. В итоге будет возвращено слово Fiction.



Как бы то ни было, главное отличие между примитивной и объектной формами строки — это существенное количество лишнего багажа, присущего объекту


ЧИСЛА В JAVASCRIPT

Отмечу еще, что в JavaScript все числа конвертируются в 64-битные числа с плавающей точкой.



let foo = {
a: "Hello",
b: "Monday";
}


Для считывания свойства нужно просто обратиться к нему напрямую:
console.log(foo.a);

Записываются же значения в свойства вполне ожидаемым способом:
foo.a = "Manic";


let zorb = {
  message: "Blah",
  get greeting() {
    return this.message;
  },
  set greeting(value) {
    this.message = value;
  }
};

Эти ключевые слова и пары функций известны как геттеры и сеттеры соответственно. Особенными их делает то, что мы не обращаемся к greeting как к функции, а делаем это так же, как и с обычным свойством:

zorb.greeting = "Hola!";
console.log(zorb.greeting);


ОБ ОБЪЕКТАХ ПОДРОБНЕЕ

Создание объектов

Первое, что мы рассмотрим, — это создание объекта. Для этого существует несколько способов, но все крутые ребята создают их с помощью забавного (но компактного) синтаксиса объектного литерала:
let funnyGuy = {};

Все верно. Вместо написания new Object(), как это делали еще ваши деды, мы можем просто инициализировать наш объект, используя {}.


Добавление свойств

Продолжим с нашего объекта funnyGuy:

let funnyGuy = {};

Предположим, мы хотим добавить свойство firstName и задать ему значение Conan. Добавление свойства в данном случае производится с помощью синтаксиса записи через точку:
funnyGuy.firstName = "Conan";

Вот и все. После добавления свойства мы можем обращаться к нему посредством того же синтаксиса:
let funnyFirstName = funnyGuy.firstName;


Удаление свойств
delete colors.footer;

// или
delete colors["footer"];


ОБЪЕКТ НЕ ЯВЛЯЕТСЯ ЧАСТЬЮ ЦЕПОЧКИ ПРОТОТИПА


В отличие от классических языков, использующих классы как шаблоны для объектов, в JavaScript понятия классов, строго говоря, не существует. 
Здесь используется так называемая модель наследования прототипов. Вы не инстанцируете объекты из шаблона. 
Вместо этого вы создаете их либо заново, либо, чаще всего, копированием или клонированием другого объекта.



var man = Object.create(null);
defineProperty(man, 'sex', "male");

var yehuda = Object.create(man);
defineProperty(yehuda, 'firstName', "Yehuda");
defineProperty(yehuda, 'lastName', "Katz");

yehuda.sex       // "male"
yehuda.firstName // "Yehuda"
yehuda.lastName  // "Katz"

Object.getPrototypeOf(yehuda) // returns the man object


ИСПОЛЬЗОВАНИЕ КЛАССОВ

в ES6-версии JavaScript появилась поддержка так называемых классов.

class Planet {
}

Для создания объекта на основе этого класса вам всего лишь нужно сделать следующее:
let myPlanet = new Planet();

Конструктор — это функция (или метод), существующий внутри тела класса. 
Он отвечает за инициализацию создаваемых объектов, и делает он это, выполняя содержащийся в нем код, во время самого процесса создания. 
Эта деталь является обязательной. Все классы должны быть оснащены функцией-конструктором. 
Если у вашего класса таковой не имеется (как у Planet), JavaScript автоматически создаст пустой конструктор за вас.

Теперь давайте определим конструктор для нашего класса Planet. Взгляните на следующую модификацию:
class Planet {
	constructor(name, radius) {
		this.name = name;
		this.radius = radius;
	}
}


Хоть мы и изучаем синтаксис class и окружающие его детали, всегда помните, что все это лишь посыпка — изысканный синтаксический сахар, разработанный для облегчения вашей жизни. 
Если не использовать синтаксис class, то можно сделать так, например:


function Planet(name, radius) {
	this.name = name;
	this.radius = radius;
};

let myPlanet = new Planet("Earth", 6378);
console.log(myPlanet.name); // Земля


Расширение объектов

class Planet {
	constructor(name, radius) {
		this.name = name;
		this.radius = radius;
	}
	getSurfaceArea() {
		let surfaceArea = 4 * Math.PI * Math.pow(this.radius, 2);
		console.log(surfaceArea + " square km!");
		return surfaceArea;
	}
	set gravity(value) {
		console.log("Setting value!");
		this._gravity = value;
	}
	get gravity() {
		return this._gravity;
	}
}

class PotatoPlanet extends Planet {
	constructor(name, width, potatoType) {
		super(name, width);
		this.potatoType = potatoType;
	}
	getPotatoType() {
		let thePotato = this.potatoType.toUpperCase() + "!!1!!!";
		console.log(thePotato);
		return thePotato;
	}
}


Логическая функция

Во всех этих примерах переменная bool вернет false:
let bool;
bool = Boolean(null);
bool = Boolean(undefined);
bool = Boolean();
bool = Boolean(0);
bool = Boolean("");
bool = Boolean(false);

В этих примерах переменная bool вернет true:
let bool;
bool = Boolean(true);
bool = Boolean("hello");
bool = Boolean(new Boolean()); // Внедрение!!!
bool = Boolean("false"); // "false" — это строка
bool = Boolean({});
bool = Boolean(3.14);
bool = Boolean(["a", "b", "c"]);


Если дополнить логику происходящего, это означает, что следующая инструкция if также будет вычислена как true:
let boolObject = new Boolean(false);
	if (boolObject) {
	console.log("Bool, you so crazy!!!");
}
При этом не важно, если вычисляемый нами объект скрывает в себе значение false... или объект String или Array и т. д. 
Правила, касающиеся примитивов, гораздо проще. Если мы передаем примитив (или то, что вычисляется как примитив), то все, 
за исключением null, undefined, 0, пустой строки, NaN или false, будет вычисляться как true.


NULL И UNDEFINED


let name = null;
if (name === null) {
	name = "Peter Griffin";
	} else {
	name = "No name";
}

Примитив null не появляется сам собой. Его вы присваиваете сознательно, поэтому предстоит часто встречаться с ним в 
объявлениях переменных или среди аргументов, передаваемых в вызовы функций. Использовать null легко. Проверить его наличие также несложно:

if (name === null) {
// делает что-нибудь интересное или нет
}

Имейте в виду, что при этом нужно использовать более строгий оператор === вместо ==. 
Хоть от использования == конец света и не наступит, но при работе с null лучше производить проверку как значения, так и типа.

NULL == UNDEFINED, НО NULL !== UNDEFINED

Продолжая тему странности == и ===: если вы когда-нибудь проверите null == undefined, то ответом будет true. 
Если же вы используете ===, то есть null === undefined, то ответом будет false.
Причина в том, что == производит приведение, присваивая значениям такие типы, какие JS посчитает целесообразными. 
Используя ===, вы проверяете и тип, и значение. Это уже полноценная проверка, которая определяет, что undefined и null на деле являются двумя разными вещами.
Монету в шляпу шестиглазому (то есть Тревору Маккаули) за то, что указал на это!



https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse

JSON.parse()
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);

console.log(obj.count);
// expected output: 42

console.log(obj.result);
// expected output: true


JS, БРАУЗЕР И DOM


ОБЪЕКТ WINDOW
Действия, которые вы можете совершать с помощью объекта window, включают:
 обращение к текущему URL, 
 получение информации о любых рамках страницы, 
 использование локального хранилища, 
 просмотр информации об экране, 
 работу с полосой прокрутки, 
 установку текста строки состояния и различные другие действия, 
 применимые к контейнеру, 
 в котором отображена страница.
 
 
QUERYSELECTOR
 
На базовом уровне функция querySelector работает так:
let element = document.querySelector("CSS selector");
 
<div id="main">
<div class="pictureContainer">
<img class="theImage" src="smiley.png" height="300" width="150" />
</div>
<div class="pictureContainer">
<img class="theImage" src="tongue.png" height="300" width="150" />
</div>
<div class="pictureContainer">
<img class="theImage" src="meh.png" height="300" width="150" />
</div>
<div class="pictureContainer">
<img class="theImage" src="sad.png" height="300" width="150" />
</div>
</div>

Например, если мы захотим обратиться к div с id main из недавнего примера, то напишем следующее:
let element = document.querySelector("#main");


Аналогичным образом давайте определим селектор для класса pictureContainer:
let element = document.querySelector(".pictureContainer");


querySelectorAll
Функция querySelectorAll возвращает все найденные элементы, которые совпадают с предоставленным вами селектором:
let elements = document.querySelectorAll("CSS selector");


let images = document.querySelectorAll(".theImage");
for (let i = 0; i < images.length; i++) {
	let image = images[i];
	console.log(image.getAttribute("src"));
}

Если вам понадобится нацелиться на все элементы img без необходимости указывать значение класса, то вот как может выглядеть вызов querySelectorAll:
let images = document.querySelectorAll("img");

Если вы захотите нацелиться только на изображение, чей атрибут src установлен как meh.png, то можете сделать следующее:
let images = document.querySelectorAll("img[src='meh.png']");


Если мне нужен только непосредственно элемент img, содержащийся внутри его родителя div, то я могу написать 

querySelector("div + img"). Это все очень круто.


Во всем этом захватывающем процессе поиска элементов недостает функций getElementById, getElementsByTagName и getElementsByClassName. 
В свое время именно они использовались для поиска элементов в DOM. 
Функции querySelector и querySelectorAll — это настоящее и будущее решение этой задачи, поэтому не стоит беспокоиться о перечисленных функциях getElement*. 
На данный момент единственным их преимуществом перед querySelector и querySelectorAll является производительность. getElementById весьма быстра.



textContent 
<body>
<h1 id="bigMessage" class="highlight summer">What's happening?</h1>
<script>
let headingElement = document.querySelector("#bigMessage");
headingElement.textContent = "Oppa Gangnam Style!";
</script>
</body>


Значения атрибутов

<body>
<h1 id="bigMessage" class="highlight summer">What's happening?</h1>
<script>
let headingElement = document.querySelector("h1");
console.log(headingElement.getAttribute("id")); // bigMessage
</script>
</body>

<body>
<h1 id="bigMessage" class="highlight summer">What's happening?</h1>
<script>
let headingElement = document.querySelector("h1");
headingElement.setAttribute("class", "bar foo");
</script>
</body>


// поиск элемента и установка классов
<body>
<h1 id="bigMessage" class="highlight summer">What's happening?</h1>
<script>
let headingElement = document.querySelector("h1");
console.log(headingElement.id); // bigMessage
headingElement.className = "bar foo";
</script>
</body>


CТИЛЬ КОНТЕНТА


чтобы добавить или удалить класс стиля можно поработать с classList
Чтобы добавить значение класса элементу, получите ссылку на этот элемент и вызовите для него метод add через classList:

let divElement = document.querySelector("#myDiv");
divElement.classList.add("bar");
divElement.classList.add("foo");
divElement.classList.add("zorb");
divElement.classList.add("baz");
console.log(divElement.classList);

Если же мы укажем недопустимое значение класса, API classList будет ругаться и добавлять его не станет. 
Если мы прикажем методу add добавить класс, уже существующий в элементе, то код по-прежнему будет выполняться, 
но повторяющееся значение класса добавлено не будет.


Переключение значений класса
Для многих сценариев стилизации применяется стандартный рабочий процесс. Во-первых, мы проверяем, существует ли значение класса в элементе. Если да, мы удаляем его из элемента. Если же нет, то мы, наоборот, его добавляем. Чтобы упростить этот тривиальный шаблон переключения, API classList предоставляет метод toggle:
let divElement = document.querySelector("#myDiv");
divElement.classList.toggle("foo"); // удаляет foo
divElement.classList.toggle("foo"); // добавляет foo
divElement.classList.toggle("foo"); // удаляет foo
console.log(divElement.classList);

Метод toggle при каждом вызове добавляет указанное значение класса в элемент или удаляет его. 
В нашем случае класс foo при первом вызове метода toggle удаляется. Во второй раз класс foo, наоборот, добавляется. 
В третий раз снова удаляется. Думаю, суть вы уловили.


Проверка наличия значения класса
Последним рассмотрим метод contains:
let divElement = document.querySelector("#myDiv");
if (divElement.classList.contains("bar") == true) {
// делает что-нибудь
}
Этот метод проверяет, существует ли указанное значение класса в элементе. Если да, то возвращается true, если нет — false



Создание элементов
let myElement = document.createElement("p");


КЛОНИРОВАНИЕ ЭЛЕМЕНТОВ

let bodyElement = document.querySelector("body");
let item = document.querySelector("h1");
let clonedItem = item.cloneNode(false);
// добавление клонированного элемента в DOM
bodyElement.appendChild(clonedItem);


Клонирование производится с помощью вызова функции cloneNode для нужного элемента с аргументом true или false — это определяет, 
хотим мы клонировать только сам элемент или еще и всех его потомков.


Обзор Chrome Dev Tools: http://bit.ly/kirupaChromeDevTools

Прослушивание событий

Используется она следующим образом:
source.addEventListener(eventName, eventHandler, false);

Source (источник)
Мы вызываем addEventListener через элемент или объект, в котором мы хотим прослушивать события. Как правило, это будет элемент DOM, но им также может быть document, 
window или другой объект, специально созданный для запуска событий.

Event Name (имя события)
В виде первого аргумента для функции addEventListener мы указываем имя события, которое хотим прослушивать.


Event Name (имя события)
В виде первого аргумента для функции addEventListener мы указываем имя события, которое хотим прослушивать.

document.addEventListener("click", changeColor, false);
function changeColor(event) {
// I am important!!!
}

аргумент события указывает на объект события и этот объект передается как часть срабатывания события


событие стартует из корня вашего документа.

Как только наше событие достигнет своей цели, оно не остановится и, как кролик из известной рекламы батареек, 
продолжает движение по своим следам обратно к корню.

Выбор фазы — это тонкая деталь, которую вы определяете с помощью true или false в вызове addEventListener:
item.addEventListener("click", doSomething, true);

Чтобы прослушивать его в обеих фазах, можно сделать следующее:
item.addEventListener("click", doSomething, true);
item.addEventListener("click", doSomething, false);


Чтобы прекратить существование события, можно использовать метод stopPropagation в объекте Event:

function handleClick(e) {
e.stopPropagation();
// что-нибудь делает
}

Метод stopPropagation прекращает движение события по фазам.

ЗАГРУЗКА DOM

Когда элемент сценария <SCRIPT> считывается, браузер приостанавливает выполнение всего остального на странице на время выполнения его кода. 
Если речь идет о длительно выполняемом сценарии или внешнем сценарии, требующем время на загрузку, HTML-страница будет попросту заморожена. 
Если же на этот момент ваша DOM будет считана лишь частично, то страница помимо остановки еще и будет выглядеть незавершенной.

























































 
 
 














































































































